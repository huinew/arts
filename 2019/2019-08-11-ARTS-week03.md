### Alogrhthm

> **283. Move Zeroes**

> Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

> Example:
> 
> Input: [0,1,0,3,12]

> Output: [1,3,12,0,0]

> Note:
> 
> You must do this in-place without making a copy of the array.
> Minimize the total number of operations.

这题比较简单，思路也是用双指针来解决，下面给出代码：
```
 public void moveZeroes(int[] nums) {
        if (nums.length == 1){
            return;
        }
        int  i = 0;

        for (int j = 0; j < nums.length; j++){
            if (nums[j] != 0){
                nums[i++] = nums[j];
            }
        }
        for (; i < nums.length; i++){
            nums[i] = 0;
        }
    }
```


### Review
[Full Cycle Developers at Netflix — Operate What You Build](https://medium.com/netflix-techblog/full-cycle-developers-at-netflix-a08c31f83249)

本文是Netflix官网上的文章，主要内容讲述了让开发人员充当软件生命周期的各个角色，自己开发、测试、维护的事情。感觉看完后非常向往这种模式。现在公司里面也是在往这个方向发展，作为一个开发人员，写完代码，写好单元测试，做好持续集成，灰度测试，没有问题就进行上线。这种模式看起来非常高效，但对底层支撑的要求也非常高。作者在文中也提到了这一项做法的tradeOff

让开发人员充当软件生命周期的所有角色，好处就是开发人员有对软件有了更全面的考虑，因为他们不仅是开发，同时也是测试、运维、售后，为了提高效率，他们会努力把能自动化的地方进行自动化，重构代码以便更好测试及维护，在代码中增加相应的警告和监控，同时运用基础支撑的问题排错工具，以更高的效率、稳定的速度产出更多的价值。

上面这些听起来很美好把，但你也能感觉到，这里面涉及的东西也是很复杂的，首先，基础支撑的工具要跟上，没有合适的工具，突发问题时，在庞大的系统中查找问题将令人非常头疼，而为了满足这点，Netflix是有一个专门的工具团队支撑各业务团队。同时，对开发人员，对其知识的广度要求更高了，如果一个开发人员没有足够的能力去处理，可能导致整个团队都陷入在救火的状态中。如果你想借鉴Netflix的做法，不妨先停下来想想，因为毕竟不是每个公司都有Netflix这样的规模及复杂度。但让开发人员负责软件开发全周期，在一个开发迭代速度较快的的确是一个好的实践。

### Tips 算法学习-时间复杂度分析及数组的应用（from 极客时间）

对于算法，比较核心的一块内容就是时间复杂度分析。那么时间复杂度到底是什么？

时间复杂度，是一种随着数据规模增大，代码执行时间的变化趋势。

**为什么需要分析时间复杂度？**

你可能会说，这个变化趋势，我通过写完代码之后运行一下得出结论不也可以吗？当然可以，不过这结果受机器的影响非常大，而且数据规模也会有较大影响。所以，我们需要一个不需要数据就能粗略估算这段代码执行效率的办法。

**如何分析时间复杂度**

王峥在他的算法专栏里面提到三点：
1. 只关注循环次数最多的代码。看下面一段例子：
```
int cal(int n) {
   int sum_3 = 0;
   int i = 1;
   for (; i <= n; ++i) {
       sum_3 = sum_3 +  i;
   }
   return sum_3;
 }
```
在这个例子里循环次数最多的是下列两行代码，循环次数是n
 
```
for (; i <= n; ++i) {
       sum_3 = sum_3 +  i;
   }
```
2. 总复杂度等于量级最大的那段代码

在下面这段求和代码里，第一段的时间复杂度是O(n)，第二段的时间复杂度是O(n^2)，那么这段代码的时间复杂度T(n) = max(O(n), O(n^2))，复杂度即为O(n^2))。

```
int cal(int n) {

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_2 + sum_3;
 }
```


3. 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
在下列这段代码里，cal有一段复杂度为O(n)的循环，而这个循环中调用了f函数，f函数也是O(n)的复杂度，那我们cal函数的复杂度就是
O(n) = g(O(n)) * k(O(n)= n^2
```
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

##### **数组**

数组我们都非常熟悉，它属于线性表，由多个相同数据类型的变量组成的，而且存储上是连续的内存。
###### 特点

由于他的内存是连续的地址，所以它能支持随机访问。所以数组在随机查找方面，它的时间复杂度为O（1），
###### 插入和删除
最好情况下，时间复杂度是O（1）（即直接在尾部插、删），最坏情况是O(n)，数组要求有序，所有元素都得移动。但对于删除，如果不要求元素有序，其实还有一种O（1）的解法，就是将要删除的元素进行标识，并不进行元素的移除，直到数组没有空间，再统一进行移除。
###### 与容器的比较
在Java中，我们也经常使用ArrayList进行数据的存储。那么他跟数组的区别有什么不同？
首先ArrayList封装了数组操作的细节，可以实现动态扩容，搬运数组元素的功能。第二存储的是必须是Integer这类装箱的类型，在装箱、拆箱会有一定的损耗。
###### 数组的应用场景
1. 一些需要关注性能的，只需基本类型即可的。
2. 大小基本是提前可知的，不怎么变化的。

###### 真实应用案例
上面提到的数组删除的解法，其实就是JVM垃圾回收的删除标识法，这样避免了每次删除操作的元素搬移，效率就会比较高。

### Share 分享
高级语言中的垃圾回收（上） 还没写完，要继续补充。。。
https://www.jianshu.com/p/f608fb3a2c40