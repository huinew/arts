## Algorithm
Source：Leetcode

Category：Dynamic programming
300.Longest Increasing Subsequence

Resolution in Java:
```
		 int maxLength = 1;
		 if (nums.length == 0) {
			 return 0;
		 }
		 
		 if (nums.length == 1) {
			 return 1;
		 }
		 int[] cell = new int[nums.length];
		 cell[0] = 1;
		 int i = 0;
		 int j = 1;
		 
		 for (i= 1; i< nums.length ; i++) {
			 int max = 0;
			 for(j = 0; j < i ; j++) {
				if (nums[i] > nums[j]) {
					max = Math.max(cell[j], max); 
				} 
			 }
			 cell[i] = max + 1;
			 maxLength = Math.max(cell[i], maxLength);
		 }
		return maxLength;
```
## Review
97 Things Every programmer should know:Automate Your Coding Standard




## Tips 
#### 从一次简单的性能测试说起
上周的时候我给自己的项目做了一次简单的性能测试，之所以说是简单，是因为项目本身没有高性能要求：测一下对外接口的执行耗时。

项目本也非常的简单，就是集成业务规则引擎，然后对外暴露出执行实例的增、删、执行、查询这几个接口。其中，增、删、执行这几个接口都是走消息队列；本次只测这三个接口；

具体测试的路径基本就是从rabbitMQ中消费消息，消费完后，将执行的数据写入到数据库中；

测试的办法非常原始，先生产1w条消息放到消息队列里，然后再开启消费者去消费消息。此处我在创建执行实例，每次创建都会在数据库里插入5行数据（创建多少行数据由业务规则文件决定)；

测试结果发现，插入1w条数据，最终花了47s，每条耗时大多是在40ms-120ms不等，平均1条50ms作用，我问了下架构师，他说算是正常水平，直接写数据库都比较慢。其他接口的测试方式也是类似如此；

**到这里，可能大家觉得这个测试方法也太简陋了，后续我们如果要做一些技术含量更高的项目，就不能这么简单测了，那有没有一些系统的测试方法，或是趁手的工具可以给我们使用呢？** 

我看了下，压力测试工具提的比较多的，就是 ***JMeter***，至于JMeter我使用了下，总结了一个记录，之后发出来。


## Share
#### 时常变需求的需求方
我们都说，产品需求应该是来源于用户；我们的需求改动也应该是来自用户的要求，然而，我们这边的用户比较奇怪，基本就是我们的老板，所有的需求都基本是老板脑中的想法；

现在我所在的公司，老板总是希望快速的产出东西，用到业务上，这本来是好事。但他希望产出的东西总是大而全，想着做完一条产业链，一步做得比美团还大。核心的卖点，连我们自己也搞不清楚。但老板觉得这是对的，那我们就干呗，毕竟老板知道的信息比我们多嘛。

于是验证想法的一个个demo做出来了，老板们很高兴，又继续提了自己的一些想法，产品经理们发现，需求又变了。开发人员们拼死拼活地把老大们脑中的亮点实现了，结果发现没有使用的用户；但还没等他们闲下来多久，又有一堆老板的想法就丢过来了；老板看着别人的产品中，他们有这功能，我们也应该有，而且要弄得更好；而底下勤奋的开发者们，淹没在领导的各种需求中，忙得不可开交，却又不知道未来真正的用户在何方。


